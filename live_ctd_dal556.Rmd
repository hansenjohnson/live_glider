---
title: "Live CTD: DAL556"
output: html_document
---

```{r setup, include=FALSE}
# specify default behaviour for code chunks
knitr::opts_chunk$set(echo = FALSE, warning = F, error = F, message = F, fig.height = 5, fig.width = 7)
```

### Summary

Dal556 was deployed in the southern Gulf of St. Lawrence to explore the Orphaline Channel region as a potential habitat of the endangered North Atlantic right whale, as well as other baleen whales. This mission also provides reconnaissance for survey vessels and planes searching for right whales in the region. 

This page provides a simple visualization of quasi-live CTD data. As this is my personal site this page may not always function properly or be kept up to date. See the following websites (from the professionals) for more details about this deployment: 

[WHOI DCS website](http://dcs.whoi.edu/dal0617_dal556/dal0617_dal556.shtml) - real-time whale detections, glider diagnostics, and more from Mark Baumgartner at WHOI

[OTN website](http://gliders.oceantrack.org/deployments.php?mission_id=74>) - glider diagnostics from the OTN glider team

```{r libraries, echo=FALSE, error=FALSE, warning=FALSE, message=FALSE, results = 'hide'}

# Set up environment ------------------------------------------------------

rm(list = ls())
# load in various required packages and data
library(data.table, quietly = T, warn.conflicts = F)
library(ggplot2, quietly = T, warn.conflicts = F)
library(plotly, quietly = T, warn.conflicts = F)
library(oce, quietly = T, warn.conflicts = F)
library(ocedata, quietly = T, warn.conflicts = F)
library(cowplot, quietly = T, warn.conflicts = F)
library(plyr, quietly = T, warn.conflicts = F)
library(lubridate, quietly = T, warn.conflicts = F)
library(marmap, quietly = T)
library(gridExtra, quietly = T)
data(coastlineWorldFine)
load('bathy.rda')
```

```{r proc, echo=FALSE, results = 'hide'}
# Get data from server ----------------------------------------------------

ctd_file = "http://gliders.oceantrack.org/data/live/dal556_sci_water_live.csv"
ctd = fread(ctd_file)

# Manipulate data frame ---------------------------------------------------

# make timestamps intelligable (convert from unixtime)
ctd$time <- as.POSIXct(ctd$unixtime, tz ="America/Halifax", origin = "1970-01-01 00:00:00")

# convert from dbar to bar
ctd$sci_water_pressure = ctd$sci_water_pressure*10

# calculate salinity
ctd$salinity = swSCTp(conductivity = ctd$sci_water_cond, 
                      temperature = ctd$sci_water_temp,
                      pressure = ctd$sci_water_pressure,
                      conductivityUnit = "S/m")

# calculate density
ctd$density = swRho(salinity = ctd$salinity, 
                    temperature = ctd$sci_water_temp, 
                    pressure = ctd$sci_water_pressure)
```

### Plots

Plots generated at: `r Sys.time()`

Latest glider timestamp: `r max(ctd$time)`

Using CTD data from: `r ctd_file`

```{r build_plots, echo=FALSE, results = 'hide'}
##### make pretty plots with ggplot #####
plot_text = paste0('Plotting all ', nrow(ctd), ' data points...')

# Only plot a subset of data 
if(nrow(ctd)>10000){
  norig = nrow(ctd) # original number of points
  nsub = round(nrow(ctd)/10000,0) # every n number of samples to plot
  ctd = ctd[seq(1, nrow(ctd), nsub),] # subset to plot every other data point

  plot_text = paste0('Plotting all ', norig, ' points will take too long. Plotting every ', nsub, ' points instead...')
}

# remove spurious values recorded at the surface
ctd$salinity[which(ctd$sci_water_pressure < 1 & ctd$salinity < 15)] = NA
ctd$sci_water_temp[which(ctd$sci_water_pressure < 1 & ctd$sci_water_temp <= 0)] = NA

temp = ggplot()+
  geom_line(data = ctd, aes(x = time, y = sci_water_pressure), colour = 'grey', na.rm = TRUE)+
  geom_point(data = ctd, aes(x = time, y = sci_water_pressure, colour = sci_water_temp), na.rm = TRUE)+
  scale_colour_gradientn(colours = oce.colorsTemperature(200)) +
  scale_y_reverse() +
  labs(x = '', y = 'Pressure [dbar]', title = 'Temperature [deg C]', colour = '_______')+
  theme_bw()

sal = ggplot()+
  geom_line(data = ctd, aes(x = time, y = sci_water_pressure), colour = 'grey', na.rm = TRUE)+
  geom_point(data = ctd, aes(x = time, y = sci_water_pressure, colour = salinity), na.rm = TRUE)+
  scale_colour_gradientn(colours = oce.colorsSalinity(200)) +
  labs(x = '', y = 'Pressure [dbar]', title = 'Salinity', colour = '_______')+
  scale_y_reverse() +
  theme_bw()

dens = ggplot()+
  geom_line(data = ctd, aes(x = time, y = sci_water_pressure), colour = 'grey', na.rm = TRUE)+
  geom_point(data = ctd, aes(x = time, y = sci_water_pressure, colour = density), na.rm = TRUE)+
  scale_colour_gradientn(colours = oce.colorsDensity(200)) +
  labs(x = '', y = 'Pressure [dbar]', title = 'Density [kg/m3]', colour = '_______')+
  scale_y_reverse() +
  theme_bw()
```

`r plot_text`

### Map

```{r map}

# vars for plotting dimensions
# plotting dimensions
mlon = median(ctd$lon)
mlat = median(ctd$lat)
span = ceiling(geodDist(latitude1 = min(ctd$lat), longitude1 = min(ctd$lon),
                        latitude2 = max(ctd$lat), longitude2 = max(ctd$lon)))*2

# plot coastline
plot(coastlineWorldFine, clon = mlon, clat = mlat, span = span)

# plot bathymetry
contour(bathyLon,bathyLat,bathyZ,levels = c(-50, -100, -150, -200, -250),lwd = c(1, 1, 2, 2, 3),lty = c(3, 1, 3, 1, 3),drawlabels = TRUE,add = TRUE,col = 'darkgray')

# add depth legend
legend("bottomright",lwd = c(1, 1, 2, 2, 3),lty = c(3, 1, 3, 1, 3),col = 'darkgray',seg.len = 3,cex = 0.7,title = "Depth [m]",legend = c("50", "100", "150", "200", "250"),bg= "white")


# glider track
lines(ctd$lon, ctd$lat, col = 'blue')

# # plot timestamp each day
# date = seq(trunc(min(ctd$time), 'day'), max(ctd$time), by = 'day')
# 
# # determine day labels
# labels = data.frame()
# for(i in seq_along(date)){
#   d = ctd[which.min(abs(ctd$time - date[i])),]
#   labels = rbind(d, labels)
# }
# 
# # day labels
# daylab = labels[1:(nrow(labels)-1),]
# points(daylab$lon, daylab$lat, pch = 4)
# text(daylab$lon, daylab$lat, labels = format(round(daylab$time, 'days'), '%d-%b'), pos = 4)

# begin and end
begin = ctd[1,]
points(begin$lon, begin$lat, pch = 17, col = 'black')
# text(begin$lon, begin$lat, labels = begin$time, pos = 4, col = 'black')

latest = ctd[nrow(ctd),]
points(latest$lon, latest$lat, pch = 20, col = 'red')
# text(latest$lon, latest$lat, labels = latest$time, pos = 4, col = 'red')

# add glider legend
legend("bottomleft", lty=c(1,NA,NA), pch = c(NA, 17, 20), col = c('blue', 'black', 'red'), c('Track', paste0('Start: ', begin$time), paste0('Latest: ', latest$time)), cex = 0.7, title = 'Glider:')
```

### Sections

``` {r sections}
# # stack static ggplots
# grid.arrange(temp, sal, dens, ncol = 1)

# interactive sections
ggplotly(temp, dynamicTicks = T)
ggplotly(sal,dynamicTicks = T)
ggplotly(dens,dynamicTicks = T)
```

### Notes

There is rudimentary processing here, which includes conversion from conductivity to salinity, and density calculation (from salinity, raw pressure, and raw temperature data). I have also added some simple quality control that removes spurious temperature and salinity values recorded at the surface. Note that the axes limits (i.e. colour bars) are determined automatically so one should exercise caution if comparing these sections between deployments.

[Home](http://hansenjohnson.org/)
